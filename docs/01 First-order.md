# Example 1 - First-order effects

In this section, we use the `Teletype` effect class from the [Polysemy](https://hackage.haskell.org/package/polysemy) library as an example to explain how to handle first-order effects in the heftia-effects. The way first-order effects are handled in heftia-effects is essentially the same as the Freer itself and is almost identical to libraries in the `freer-simple` series that support only first-order effects.

## Defining the effect class

First, let's define an effect for Teletype.

```haskell
-- | `Teletype` effect class
class Teletype f where
    readTTY :: f String
    writeTTY :: String -> f ()

makeEffectF ''Teletype
```

`makeEffectF` is a Template Haskell function from the [`classy-effects-th`](https://github.com/sayo-hs/classy-effects) package. This allows the type class `Teletype` to automatically comply with all [CEPs](https://github.com/sayo-hs/classy-effects/blob/master/CEPs/README.md) (0.1.0) from CEP-01 to CEP-04.

In particular, according to [CEP-02](https://github.com/sayo-hs/classy-effects/blob/master/CEPs/CEP-02.md), GADTs like the following are automatically generated:

```haskell
-- Data type of the effect class automatically generated by `makeEffectF`
data TeletypeI a where
    ReadTTY :: TeletypeI String
    WriteTTY :: String -> TeletypeI ()
```

## Implementing the interpreter

Next, let's implement an interpreter for this `Teletype` effect class.

```haskell
-- | Interpreter for the `Teletype` effect class, interpreting it in terms of `getLine` and `putStrLn`.
teletypeToIO :: (IO <: Fre r m, Monad m) => Fre (TeletypeI ': r) m ~> Fre r m
teletypeToIO = interpret \case
    ReadTTY -> sendIns getLine
    WriteTTY msg -> sendIns $ putStrLn msg
```

The `Fre` type is the so-called Freer monad. However, it's a monad transformer of Freer, and `m` represents the underlying monad. `es` represents the type-level list of effect classes that Freer can accept. The function signature of `teletypeToIO` expresses the consumption of the `Teletype` effect, converting each of the `ReadTTY` and `WriteTTY` effects into IO actions. The `<:` operator is a synonym for the `SendIns` type class, provided by `classy-effects-base`, expressing a constraint that the left-side first-order effect data (instructions) can be sent to the right-side carrier. This is like a subtyping relationship. The `sendIns` method is used for sending. `~>` is simply defined as `type f ~> g = forall x. f x -> g x`.

Also, note the constraint `Monad m`. In principle, both heftia and classy-effects are generalized to support effects where the carrier is not a monad (e.g., Applicative effects). However, since `Fre` is a Freer for monadic effects, the underlying carrier here must be constrained to `Monad`. While it is possible to write in a generalized way for non-monadic effects (in fact, the functions provided by the heftia library are generalized this way), it's a bit verbose and will not be discussed here.

## Creating an effectful program

Next, let's write a program using the defined effects.

```haskell
echo :: (Teletype m, Monad m) => m ()
echo = do
    i <- readTTY
    case i of
        "" -> pure ()
        _ -> writeTTY i >> echo
```

This `echo` program performs a loop that echoes the string entered on the TTY. If an empty string is entered (i.e., the Enter key is pressed without entering anything), the loop exits. Note that it uses only `Teletype` and does not involve `TeletypeI`, `<:`, or `Fre`. By excluding elements related to effect data from the function interface, the program can be handled by effect system backends that are not based on GADTs, such as mtl. In other words, the constraint of dependence on a specific effect system backend is weakened, making it more generalized and polymorphic. For details on this, refer to the section "Recommendation on Interface Independence from the Effect System Backend" in [CEP-01](https://github.com/sayo-hs/classy-effects/blob/master/CEPs/CEP-02.md).

## Composing an effectful program with a handler

Let's combine the effectful program `echo` with the previously defined `teletypeToIO` interpreter to construct an actual main function.

```haskell
main :: IO ()
main = runFreerEffects do
    sendIns $ putStrLn "Please enter something..."
    teletypeToIO echo
```

The `runFreerEffects` function "runs" the `Fre` monad transformer, translating it into the underlying monad (in this case, the `IO` monad).

When executed and a string is typed in, the program behaves as follows. The program terminates when an empty string is entered.

```
Please enter something...
foo↵
foo
bar↵
bar
baz↵
baz
↵
```

## Modifying Interpretation

Next, let's explore the re-interpretation of effects using the `interpose` function. Using functions such as `reinterpret`, `interpose`, and `intercept` provided by the heftia library allows us to change the interpretation of effects on the fly. This can be thought of as a hook in the program.

To liken it to existing programming concepts, it resembles the rethrowing of exceptions. In this case, the side throwing the exception represents the effectful program, throwing the exception signifies issuing an effect, and the exception handler represents the effect handler. Once an exception is thrown, it can be caught and based on its content, a different exception can be generated and thrown.

For readers familiar with computer networking, this is analogous to a proxy rewriting packets as they traverse the network. In this analogy, the client is the effectful program, and the server is the handler (or interpreter). Functions of the reinterpretation family act like a proxy rewriting requests sent from a client to a server, modifying effects issued by the effectful program into different effects based on a provided function. Note that the original effect is consumed and won't be issued again simultaneously with the modified effect.

Below is a function that hooks into the behavior of the Teletype effect class. The `readTTY` effect retains its original behavior. However, for the `writeTTY` effect, the behavior of the original `writeTTY` is modified to append an exclamation mark at the end of the string.

```haskell
strong :: (TeletypeI <| es, Monad m) => Fre es m ~> Fre es m
strong =
    interpose \case
        ReadTTY -> readTTY
        WriteTTY msg -> writeTTY $ msg <> "!"
```

The `<|` represents a constraint expressing the membership relation of the effect class list. Using this function, the `main` function can be modified as follows:

```haskell
main :: IO ()
main = runFreerEffects do
    sendIns $ putStrLn "Please enter something..."
    teletypeToIO $ strong . strong $ echo
```

Note that `strong` is applied twice. Since `interpose` has a type of the form `f ~> f`, it can be applied multiple times.

The output will look like:

```
Please enter something...
foo↵
foo!!
bar↵
bar!!
baz↵
baz!!
↵
```

## Tagged Effects

Both classy-effects and heftia-effects support tagged effects (but this is experimental). Below is an example of tagging the code discussed so far.

```haskell
data TTY1

echo :: (Teletype (m @# TTY1), Monad m, Taggable m) => m ()
echo = do
    i <- readTTY & tag @TTY1
    case i of
        "" -> pure ()
        _ -> (writeTTY i & tag @TTY1) >> echo

strong :: (TeletypeI # TTY1 <| es, Monad m) => Fre es m ~> Fre es m
strong =
    interpose @(_ # TTY1) \e -> case getTag e of
        ReadTTY -> readTTY & tag @TTY1
        WriteTTY msg -> writeTTY (msg <> "!") & tag @TTY1

main :: IO ()
main = runFreerEffects $ do
    sendIns $ putStrLn "Please enter something..."
    teletypeToIO . untag @TTY1 . strong . strong $ echo
```

Firstly, a type tag `TTY1` is defined[^1].

[^1]: Of course, you can use type-level strings as tags, but to make error messages more understandable when a typo occurs, it's recommended to define a new data type for tags.

Tagging a carrier is done using the `@#` operator, allowing you to express constraints for tagged effect classes. Then, using the `tag` function, effects within that scope that haven't been tagged can be transmitted to the carrier in a tagged state.

For effect class data-types, you can tag first-order ones with the `#` operator. For higher-order effect classes discussed in the next section, use the `##` operator.

Furthermore, when handling, to revert the tag and get back to the base `TeletypeI`, use `untag @TTY1`.

Future versions of classy-effects plan to support concise tagging like `readTTY & tag @TTY1` being written as `readTTY' @TTY1`.

## Entire Code

The complete code is as follows. Note the many GHC extensions implicitly enabled.

```haskell
{-# LANGUAGE TemplateHaskell #-}

module Main where

import Control.Effect.Class (sendIns, type (<:), type (~>))
import Control.Effect.Class.Machinery.TH (makeEffectF)
import Control.Effect.Freer (Fre, interpose, interpret, runFreerEffects, type (<|))

class Teletype f where
    readTTY :: f String
    writeTTY :: String -> f ()

makeEffectF ''Teletype

teletypeToIO :: (IO <: Fre es m, Monad m) => Fre (TeletypeI ': es) m ~> Fre es m
teletypeToIO = interpret \case
    ReadTTY -> sendIns getLine
    WriteTTY msg -> sendIns $ putStrLn msg

echo :: (Teletype m, Monad m) => m ()
echo = do
    i <- readTTY
    case i of
        "" -> pure ()
        _ -> writeTTY i >> echo

strong :: (TeletypeI <| es, Monad m) => Fre es m ~> Fre es m
strong =
    interpose \case
        ReadTTY -> readTTY
        WriteTTY msg -> writeTTY $ msg <> "!"

main :: IO ()
main = runFreerEffects $ do
    sendIns $ putStrLn "Please enter something..."
    teletypeToIO $ strong . strong $ echo
```

### Code with Tagged Effects

```haskell
{-# LANGUAGE TemplateHaskell #-}

module Main where

import Control.Effect.Class (Taggable, getTag, sendIns, tag, type (#), type (<:), type (@#), type (~>))
import Control.Effect.Class.Machinery.TH (makeEffectF)
import Control.Effect.Freer (Fre, interpose, interpret, runFreerEffects, untag, type (<|))
import Data.Function ((&))

class Teletype f where
    readTTY :: f String
    writeTTY :: String -> f ()

makeEffectF ''Teletype

teletypeToIO :: (IO <: Fre es m, Monad m) => Fre (TeletypeI ': es) m ~> Fre es m
teletypeToIO = interpret \case
    ReadTTY -> sendIns getLine
    WriteTTY msg -> sendIns $ putStrLn msg

data TTY1

echo :: (Teletype (m @# TTY1), Monad m, Taggable m) => m ()
echo = do
    i <- readTTY & tag @TTY1
    case i of
        "" -> pure ()
        _ -> (writeTTY i & tag @TTY1) >> echo

strong :: (TeletypeI # TTY1 <| es, Monad m) => Fre es m ~> Fre es m
strong =
    interpose @(_ # TTY1) \e -> case getTag e of
        ReadTTY -> readTTY & tag @TTY1
        WriteTTY msg -> writeTTY (msg <> "!") & tag @TTY1

main :: IO ()
main = runFreerEffects $ do
    sendIns $ putStrLn "Please enter something..."
    teletypeToIO . untag @TTY1 . strong . strong $ echo
```
